const SongService = require("../../services/songService");
const cloudinary = require("../../utils/config/cloudinary");
const musicMetadata = require("music-metadata");

class SongController {
  async getAll(req, res) {
    try {
      const songs = await SongService.getAllSongs();
      res.status(200).json({ success: true, data: songs });
    } catch (err) {
      res.status(500).json({ success: false, message: err.message });
    }
  }

  async getById(req, res) {
    try {
      const song = await SongService.getSongById(req.params.id);
      res.status(200).json({ success: true, data: song });
    } catch (err) {
      res.status(404).json({ success: false, message: err.message });
    }
  }


  // ‚úÖ H√†m helper ƒë·ªÉ chu·∫©n h√≥a ng√†y th√°ng
  static normalizeDate(dateString) {
    if (!dateString) return null;
    // ƒê·∫£m b·∫£o format YYYY-MM-DD v√† th√™m th·ªùi gian 12:00:00 ƒë·ªÉ tr√°nh timezone issue
    const date = new Date(dateString + 'T12:00:00');
    return date.toISOString().split('T')[0];
  }

  // üü¢ T·∫°o b√†i h√°t m·ªõi (upload file & ·∫£nh)
  async create(req, res) {
    try {
      console.log("üì• Request body:", req.body);
      console.log("üìÅ Files:", req.files);

      const { title, lyric, singerId, genreId, releaseDate } = req.body;

      // Validation ƒë·∫ßy ƒë·ªß
      if (!title?.trim()) {
        return res.status(400).json({ 
          success: false, 
          message: "Vui l√≤ng nh·∫≠p t√™n b√†i h√°t" 
        });
      }

      if (!singerId) {
        return res.status(400).json({ 
          success: false, 
          message: "Vui l√≤ng ch·ªçn ngh·ªá sƒ©" 
        });
      }

      if (!genreId) {
        return res.status(400).json({ 
          success: false, 
          message: "Vui l√≤ng ch·ªçn th·ªÉ lo·∫°i" 
        });
      }

      // Ki·ªÉm tra file nh·∫°c b·∫Øt bu·ªôc
      if (!req.files?.file?.[0]) {
        return res.status(400).json({ 
          success: false, 
          message: "Vui l√≤ng upload file nh·∫°c" 
        });
      }


      let fileUrl = "";
      let coverUrl = "";

      if (req.files?.file?.[0]) {
        const file = req.files.file[0];
        const base64 = file.buffer.toString("base64");
        const uploadRes = await cloudinary.uploader.upload(
          `data:${file.mimetype};base64,${base64}`,
          { resource_type: "video", folder: "songs" }
        );

        duration = Math.round(metadata.format.duration || 0);
        console.log(`‚è±Ô∏è Duration: ${duration}s`);
      } catch (metaErr) {
        console.error("‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·ªçc metadata:", metaErr.message);
      }


        // T√≠nh duration t·ª´ file audio
        try {
          const metadata = await musicMetadata.parseBuffer(file.buffer, {
            mimeType: file.mimetype,
          });
          duration = Math.round(metadata.format.duration || 0);
        } catch (metaErr) {
          console.error("‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·ªçc metadata:", metaErr.message);
        }
      }

      if (req.files?.cover?.[0]) {
        const cover = req.files.cover[0];
        const base64 = cover.buffer.toString("base64");
        const uploadRes = await cloudinary.uploader.upload(
          `data:${cover.mimetype};base64,${base64}`,
          { resource_type: "image", folder: "covers" }
        );
        coverUrl = uploadRes.secure_url;
      }

      // ‚úÖ Chu·∫©n h√≥a releaseDate tr∆∞·ªõc khi l∆∞u
      const normalizedDate = SongController.normalizeDate(releaseDate);
      console.log("üìÖ Original date:", releaseDate);
      console.log("üìÖ Normalized date:", normalizedDate);

      const result = await SongService.createSong({
        title,
        duration,
        lyric: lyric || "",
        singerId,
        genreId,
        fileUrl,
        coverUrl,

        releaseDate: normalizedDate,

      });

      res.status(201).json({
        success: true,
        message: result.message,
        songId: result.songId,
      });
    } catch (err) {
      console.error("‚ùå L·ªói t·∫°o b√†i h√°t:", err);
      res.status(400).json({ success: false, message: err.message });
    }
  }

  async update(req, res) {
    try {

      const { title, lyric, singerId, genreId, releaseDate, popularityScore } = req.body;

      const songId = req.params.id;

      const existing = await SongService.getSongById(songId);
      if (!existing)
        return res
          .status(404)
          .json({ success: false, message: "Kh√¥ng t√¨m th·∫•y b√†i h√°t" });

      let fileUrl = existing.fileUrl;
      let coverUrl = existing.coverUrl;
      let newDuration = duration || existing.duration;

      if (req.files?.file?.[0]) {
        const file = req.files.file[0];
        const base64 = file.buffer.toString("base64");
        const uploadRes = await cloudinary.uploader.upload(
          `data:${file.mimetype};base64,${base64}`,
          { resource_type: "video", folder: "songs" }
        );
        fileUrl = uploadRes.secure_url;

        try {
          const metadata = await musicMetadata.parseBuffer(file.buffer, {
            mimeType: file.mimetype,
          });
          newDuration = Math.round(metadata.format.duration || 0);
        } catch (metaErr) {
          console.error("‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·ªçc metadata:", metaErr.message);
        }
      }

      if (req.files?.cover?.[0]) {
        const cover = req.files.cover[0];
        const base64 = cover.buffer.toString("base64");
        const uploadRes = await cloudinary.uploader.upload(
          `data:${cover.mimetype};base64,${base64}`,
          { resource_type: "image", folder: "covers" }
        );
        coverUrl = uploadRes.secure_url;
      }

      // ‚úÖ Chu·∫©n h√≥a releaseDate n·∫øu c√≥ c·∫≠p nh·∫≠t
      let finalReleaseDate = existing.releaseDate;
      if (releaseDate !== undefined && releaseDate !== null && releaseDate !== '') {
        finalReleaseDate = SongController.normalizeDate(releaseDate);
        console.log("üìÖ Updated date:", releaseDate, "=>", finalReleaseDate);
      }

      const result = await SongService.updateSong(songId, {
        title,
        duration: newDuration,
        lyric: lyric || "",
        singerId,
        genreId,
        fileUrl,
        coverUrl,

        releaseDate: finalReleaseDate,
        popularityScore: popularityScore !== undefined ? popularityScore : existing.popularityScore,

      });

      res.status(200).json({ success: true, message: result.message });
    } catch (err) {
      console.error("‚ùå L·ªói c·∫≠p nh·∫≠t:", err);
      res.status(400).json({ success: false, message: err.message });
    }
  }

  async delete(req, res) {
    try {
      const result = await SongService.deleteSong(req.params.id);
      res.status(200).json({ success: true, message: result.message });
    } catch (err) {
      res.status(400).json({ success: false, message: err.message });
    }
  }

  async increaseView(req, res) {
    try {
      const songId = req.params.id;
      const result = await SongService.increaseView(songId);
      res.status(200).json({ success: true, message: result.message });
    } catch (err) {
      res.status(400).json({ success: false, message: err.message });
    }
  }

  async getSongByReleaseDate(req, res) {
    try {
      const songs = await SongService.getSongByReleaseDate();
      res.status(200).json({ success: true, data: songs });
    } catch (err) {
      res.status(500).json({ success: false, message: err.message });
    }
  }

}

module.exports = new SongController();
